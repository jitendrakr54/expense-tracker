index.js is the first file to execute

We don't import our custom components in index.js, we do so only once for root.
Instead we import in App.js

Composition(Children props) :

In App.js we're using Expenses, in there we are using ExpenseItem, in there we're using ExpenseDate.
Generally, this approach of building a user interface from smaller building blocks is called composition.

Card:
Instead in general, in web development, when you hear the term card, it's typically means some kind of container look
with rounded corners, drop shadows, and elements like these.

. you can't use your custom components as wrappers around other kind of content. Having content between opening and closing tags doesn't work just like that.
eg:
<Card className="expense-item">
<ExpenseDate date={props.date} />

<div className="expense-item__description">
<h2>{props.title}</h2>
<div className="expense-item__price">${props.amount}</div>
</div>
</Card>

But of course it does work for built-in HTML elements, like the div or the h2 tag.
eg:

<div className="expense-item">
<ExpenseDate date={props.date} />
<div className="expense-item__description">
<h2>{props.title}</h2>
<div className="expense-item__price">${props.amount}</div>
</div>
</div>

So it would be nice if we could also make it work for our custom components to build such reusable wrapper components
like this, And of course, React has a solution here. We can build such wrapper components. In Card.js we again, when I accept props. But now, as I mentioned we'll not work with some attributes but instead we will use one special prop
which is built into React, which every component receives, even if you're never setting it explicitly. And that's a prop which value I wanna output between the opening and closing tag of this div, inside of the card component function.
It's the props.children prop. children is a reserved name. We don't set a children prop on this card.
I'm setting a class named prop and actually at the moment, this won't do anything. But I'm not setting a children prop.
Children, as I said, is a reserved name and the value of this special children prop will always be the content between the opening and closing tags of your custom component. So in this case, this content between the opening and closing card tag, that is what will be available on props.children inside of that card.

Now, why would we do that? What did we gain by doing that? Well, in this case, of course, not a whole lot
but we were able to extract some code duplication from inside our CSS files into this separate wrapper component.
And it's not just a duplicate CSS code. We also were able to extract this HTML code, this JSX code, this div here.
In this case, it's just one div but throughout the course you will also see more complex wrapper components
which might have a more complex JSX structure. Things like modals and alerts. And in such cases, being able to extract that often allows you to save a lot of code duplication and it often allows you to keep your other components clean.
And this is another aspect of composition. We compose our ExpenseItem component by using card as a wrapper,
by using some built-in HTML elements, and by then all the putting in the ExpenseDate. And all these components and elements are composed together to form the overall ExpenseItem component which then again, is used in other components
to in the end overall, build the overall user interface.So composition is important.
You use it all the time when working with React. Whenever you combine components, you are using composition.
And an especially important part of composition is this props children feature which allows you to also create wrapper components which is a special type of component

In App.js we directly write JSX code but how this works behind the scene. Let's convert below JSX code -

<div>
<h2>Let's get started!</h2>
<Expenses items={expenses}></Expenses>
</div>

converted:
React.createElement('div', {},
React.createElement('h2', {}, "Let's get started"),
React.createElement(Expenses, {items: expenses}));

There is a createElement method, which we can call. And when you use JSX, it's near this method which is called.
CreateElement takes three arguments. The first argument is the element which should be created. For example, a div.
And if it's a built-in HTML element,you just pass in a string with the name of that element, like div.
The second argument is an object that configures this element. Specifically, an object which sets all the attributes
of this element. This div has no attributes, so here we can pass in an empty object {}. The third argument now is the content between the opening and closing div tags. And actually it's not just a third argument. You can now have an infinitely long list of arguments, which are the different content pieces between the opening and closing tags.
So here we have two elements, so we would have two extra arguments. The third argument would be our H2 element.
So the first child in that div. And therefore here, again, we would call React createElement and create an H2 element here. And that H2 element, again, has no attributes, so the second argument of this second createElement call
would be an empty object. And the third argument of this createElement call would be the content in this H2 tag,
so this string, in this case. So we would pass this string here, and escape this single quote. And if we now format it, it would look like this. Now next to this second createElement call, We could have a third createElement call,
which is the neighbor element to this H2 element, so this expenses component. Again, we create an element here,
but now we're working with a custom component instead of a built-in one. In such cases, you don't use a string here,
but you just point at your imported function, which it in the end is, because your components are just functions, right?
So here we set Expenses. We point at Expenses as an element here. The second argument is an object of properties
that should be set, of attributes that should be set, and here we have the items prop, the items attribute,
so we would add an items key here. Keep in mind, this is just a JavaScript object, so we have the property name, and then a colon, and then the value, which here would be expenses. And then as a third argument, we have to content between the opening and closing tags. And in this case, there is no such contents, so we omit it. And this here would be the alternative to this JSX code using this React object.

And this here would be the alternative to this JSX code using this React object. And therefore, if I saved that, we go back to the screen, we see exactly the same as before. Now, you could write your entire React app like this. It just turns out that this is a bit harder to read and a bit more cumbersome than using this JSX code. But that's why you needed to import React from React in all your component files in the past, because this is the under-the-hood code
which kind of gets created automatically when you use JSX. Now in more modern project setups, you can omit this React import because the project setup is able to make that transformation without the import being added. But if you see component functions where this import is there, it is there because, in the past, you always did need to add it.
And therefore, because of that reason, I will now also import it and add it to all components where I use some JSX code.

And if you have a look at this code, it should also be clear why you need some wrapping element as a root JSX element.
Why you can't have just these two side-by-side elements being returned. Because how will you write this in the React
createElement world? You, in the end, would be trying to return this, and that doesn't work. You can't return more than one thing. You could return an array, sure, but this is not an array of elements. This is two separate elements side by side. That's why you always need such a wrapper, because in createElement world, you always create one element
which then may have more child elements. So that's why we have this one wrapper root JSX element which we always need.
This is why we need that. That's the under-the-hood, behind-the-scenes stuff

As your project grows and as you have more and more components you might want to organize them into sub folders
and not just throw them all into one components folder. And, indeed, that is something we can already get started with.Here, we could argue that we have some general UI components some general user interface elements, which are not tied to a specific feature of the app. And then, we got some features specific components, like these components, which are dealing with rendering expenses and expense data. And, therefore, in the components sub folder, we could create an Expenses sub folder, and next to that a UI sub folder for general user interface elements. And we could move the card files into the UI folder and the Expenses, ExpenseItem, and ExpenseDate files into the Expenses folder.

How can you manage more than one State?

It is something we have learned up to this point but it turns out that it is rather simple. You can call useState more than once. You can have multiple States, multiple States slices or State pieces per component. And all of these States inside of one at the same component will then all to be totally separated from each other.

// const [enteredTitle, setEnteredTitle] = useState("");
// const [enteredAmount, setenteredAmount] = useState("");
// const [enteredDate, setEnteredDate] = useState("");

However, there also is an alternative and it depends basically on your personal preferences which approach you prefer.
by calling used state only once and by passing in an object as a value and that's important not a string or number or anything like that, but an object. And of course in this object, you can now group together, your three States

const [usernput, setUserInput] = useState({
enteredTitle: "",
enteredAmount: "",
enteredDate: "",
});

You can switch between these approaches. Now, I tend to prefer the individual state slices, And I would say you also see that more often out there in the world, in other react projects, but ultimately both approaches are fine.

// setUserInput({
// ...usernput,
// enteredTitle: event.target.value,
// });

But Here, I'm depending on my previous state for updating the state. In this case, we depend on the previous state
because we used this one state instead of three-states approach and we need to copy in the other values so that we don't lose them. Hence we depend on the previous state snapshot to copy in the existing values and then just override one value with a new one. Now whenever, and that's another key rule which you should memorize, whenever you update state
and you depend on the previous state.

Better way of doing above when we use grouping state together

// setUserInput((prevState) => {
// return { ...prevState, enteredTitle: event.target.value };
// });

Now why should we do it like this instead of like this? In many cases, both will work fine, but keep in mind that I mentioned that Reacts schedules state updates, it doesn't perform them instantly. And therefore, theoretically,
if you schedule a lot of state updates at the same time, you could be depending on an outdated or incorrect state snapshot if you use this approach. If you use this approach, React will guarantee that the state snapshot it gives you here in this inner function, will always be the latest state snapshot, keeping all scheduled state updates in mind.
So this is the safer way to ensure that you always operate on the latest state snapshot. So you should use this function syntax here whenever your state update depends on the previous state. That is something you should memorize.
If your state update depends on the previous state, use this function form.

2-way bindings:
How can we clear those inputs?

All we have to do is add the value attribute, which is a default attribute, to this input element. This will set the internal value property, which every input element has. And we can set it to a new value. And here, I will bind this to enteredTitle. So now it is this two-way binding because now we don't just listen to changes in the input to update our state. But we also feed the state back into the input so that when we change the state, we also change input. This might sound like an infinite loop, but it actually isn't. So we won't have a problem there. But the advantage is that when the form is submitted for example, we can call setEnteredTitle. And set this back to an empty string, which also was our initial state. And by doing that, we override what the user entered after the form was submitted and therefore cleared the input.

value={enteredTitle}
setEnteredTitle("");
