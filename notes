index.js is the first file to execute

We don't import our custom components in index.js, we do so only once for root.
Instead we import in App.js

Composition(Children props) :

In App.js we're using Expenses, in there we are using ExpenseItem, in there we're using ExpenseDate.
Generally, this approach of building a user interface from smaller building blocks is called composition.

Card:
Instead in general, in web development, when you hear the term card, it's typically means some kind of container look
with rounded corners, drop shadows, and elements like these.

. you can't use your custom components as wrappers around other kind of content. Having content between opening and closing tags doesn't work just like that.
eg:
<Card className="expense-item">
<ExpenseDate date={props.date} />

<div className="expense-item__description">
<h2>{props.title}</h2>
<div className="expense-item__price">${props.amount}</div>
</div>
</Card>

But of course it does work for built-in HTML elements, like the div or the h2 tag.
eg:

<div className="expense-item">
<ExpenseDate date={props.date} />
<div className="expense-item__description">
<h2>{props.title}</h2>
<div className="expense-item__price">${props.amount}</div>
</div>
</div>

So it would be nice if we could also make it work for our custom components to build such reusable wrapper components
like this, And of course, React has a solution here. We can build such wrapper components. In Card.js we again, when I accept props. But now, as I mentioned we'll not work with some attributes but instead we will use one special prop
which is built into React, which every component receives, even if you're never setting it explicitly. And that's a prop which value I wanna output between the opening and closing tag of this div, inside of the card component function.
It's the props.children prop. children is a reserved name. We don't set a children prop on this card.
I'm setting a class named prop and actually at the moment, this won't do anything. But I'm not setting a children prop.
Children, as I said, is a reserved name and the value of this special children prop will always be the content between the opening and closing tags of your custom component. So in this case, this content between the opening and closing card tag, that is what will be available on props.children inside of that card.

Now, why would we do that? What did we gain by doing that? Well, in this case, of course, not a whole lot
but we were able to extract some code duplication from inside our CSS files into this separate wrapper component.
And it's not just a duplicate CSS code. We also were able to extract this HTML code, this JSX code, this div here.
In this case, it's just one div but throughout the course you will also see more complex wrapper components
which might have a more complex JSX structure. Things like modals and alerts. And in such cases, being able to extract that often allows you to save a lot of code duplication and it often allows you to keep your other components clean.
And this is another aspect of composition. We compose our ExpenseItem component by using card as a wrapper,
by using some built-in HTML elements, and by then all the putting in the ExpenseDate. And all these components and elements are composed together to form the overall ExpenseItem component which then again, is used in other components
to in the end overall, build the overall user interface.So composition is important.
You use it all the time when working with React. Whenever you combine components, you are using composition.
And an especially important part of composition is this props children feature which allows you to also create wrapper components which is a special type of component

In App.js we directly write JSX code but how this works behind the scene. Let's convert below JSX code -

<div>
<h2>Let's get started!</h2>
<Expenses items={expenses}></Expenses>
</div>

converted:
React.createElement('div', {},
React.createElement('h2', {}, "Let's get started"),
React.createElement(Expenses, {items: expenses}));

There is a createElement method, which we can call. And when you use JSX, it's near this method which is called.
CreateElement takes three arguments. The first argument is the element which should be created. For example, a div.
And if it's a built-in HTML element,you just pass in a string with the name of that element, like div.
The second argument is an object that configures this element. Specifically, an object which sets all the attributes
of this element. This div has no attributes, so here we can pass in an empty object {}. The third argument now is the content between the opening and closing div tags. And actually it's not just a third argument. You can now have an infinitely long list of arguments, which are the different content pieces between the opening and closing tags.
So here we have two elements, so we would have two extra arguments. The third argument would be our H2 element.
So the first child in that div. And therefore here, again, we would call React createElement and create an H2 element here. And that H2 element, again, has no attributes, so the second argument of this second createElement call
would be an empty object. And the third argument of this createElement call would be the content in this H2 tag,
so this string, in this case. So we would pass this string here, and escape this single quote. And if we now format it, it would look like this. Now next to this second createElement call, We could have a third createElement call,
which is the neighbor element to this H2 element, so this expenses component. Again, we create an element here,
but now we're working with a custom component instead of a built-in one. In such cases, you don't use a string here,
but you just point at your imported function, which it in the end is, because your components are just functions, right?
So here we set Expenses. We point at Expenses as an element here. The second argument is an object of properties
that should be set, of attributes that should be set, and here we have the items prop, the items attribute,
so we would add an items key here. Keep in mind, this is just a JavaScript object, so we have the property name, and then a colon, and then the value, which here would be expenses. And then as a third argument, we have to content between the opening and closing tags. And in this case, there is no such contents, so we omit it. And this here would be the alternative to this JSX code using this React object.

And this here would be the alternative to this JSX code using this React object. And therefore, if I saved that, we go back to the screen, we see exactly the same as before. Now, you could write your entire React app like this. It just turns out that this is a bit harder to read and a bit more cumbersome than using this JSX code. But that's why you needed to import React from React in all your component files in the past, because this is the under-the-hood code
which kind of gets created automatically when you use JSX. Now in more modern project setups, you can omit this React import because the project setup is able to make that transformation without the import being added. But if you see component functions where this import is there, it is there because, in the past, you always did need to add it.
And therefore, because of that reason, I will now also import it and add it to all components where I use some JSX code.

And if you have a look at this code, it should also be clear why you need some wrapping element as a root JSX element.
Why you can't have just these two side-by-side elements being returned. Because how will you write this in the React
createElement world? You, in the end, would be trying to return this, and that doesn't work. You can't return more than one thing. You could return an array, sure, but this is not an array of elements. This is two separate elements side by side. That's why you always need such a wrapper, because in createElement world, you always create one element
which then may have more child elements. So that's why we have this one wrapper root JSX element which we always need.
This is why we need that. That's the under-the-hood, behind-the-scenes stuff

As your project grows and as you have more and more components you might want to organize them into sub folders
and not just throw them all into one components folder. And, indeed, that is something we can already get started with.Here, we could argue that we have some general UI components some general user interface elements, which are not tied to a specific feature of the app. And then, we got some features specific components, like these components, which are dealing with rendering expenses and expense data. And, therefore, in the components sub folder, we could create an Expenses sub folder, and next to that a UI sub folder for general user interface elements. And we could move the card files into the UI folder and the Expenses, ExpenseItem, and ExpenseDate files into the Expenses folder.

Adding events on html element:
To all these built-in HTML elements, we can add supported event listeners basically. OnClick, for example, basically is available on every element. Some events are only available on specific elements. But that is all based on the default DOM behavior. If an element supports an event, then you can add a listener with React by adding such an on and then the event name prop. Just make sure that the event name starts with a capital character, like in the case of onClick here.
And then you just point at a function, either defined in line here or, better, defined upfront, and React will execute that function for you when that event occurs. That's how you add events.

Now, one word about naming these functions. It is a convention which you don't have to follow but which you might consider following that you name your functions like this. If they are triggered upon an event, that you end with handler. This is not a must-do, and not every React developer does it,

State is actually not a React specific concept but it is a key concept in React as well. And here in ExpenseItem,
we have a scenario where we wanna use that built-in state concept. Because this title here which changes when the clickHandler executes is actually data that should result in this component being re-evaluated and re-drawn on the screen when it's changes, when that's title data changes. And by default, regular variables like this one, are not triggering such a re-evaluation. React doesn't care about that. If you have a variable in your component function
and the that variable changes, React ignores it. It doesn't care about that, that code executes, sure,
but the overall component function doesn't execute again.

So to tell React that it should run it again, we need to import something from the React library. And we do it as by adding a so-called named import. This here, is the default import. Now, we can add a comma and curly braces and between the curly braces we can now extract specifically named things from the React library.
And we want to import a function here, a function which is called useState. This is a function provided by the React library and this function allows us to define values as state where changes to these values should reflect
in the component function being called again, which is a key difference to the regular variable we're using here.

Now, how do we use this useState function though? Well, it's very simple. Inside of our component function and that's important, we have to do that inside of this function. We just call useState. And useState is a so-called React hook.
And all these React hooks can be recognized by the fact that they start with the word "use" in their name,
and all these hooks must only be called inside of React component functions like ExpenseItem. They can't be called outside of these functions, like this. And they all just shouldn't be called in any nested functions.
They must be called directly inside such component functions. There is one exception which we'll talk about later
but for the moment, that is what you should keep in mind.

we will be assigning new values by calling a function. That's just how this state variable thing works. And for that useState actually returns an array where the first value is the variable itself, you could say, the value itself.
And the second element in the array is that updating function.

UseState registers some State, so some value as a State for the component in which it is being called. And I wanna be even more precise here. It registers it for a specific component instance. For example, ExpenseItem here is being used four times, right? And Expenses.js we have four ExpenseItems. Now, every item receives its own separate State
which is detached from the other States. We have one ExpenseItem definition here, but then this function is basically called four times when we create four ExpenseItems. And every time it's called, a new separate State is created
of course in the same way but managed independently by React. So if we change the title in the first ExpenseItem
the other ones are not affected because they have their own State. That's really important. It's on a per component instance basis.

Thus far, we update our state upon user events (e.g. upon a click).
That's very common but not required for state updates! You can update states for whatever reason you may have.
Later in the course, we'll see Http requests that complete (where we then want to update the state based on the Http response we got back) but you could also be updating state because a timer (set with setTimeout()) expired for example.
